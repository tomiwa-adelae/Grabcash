generator client {
  provider = "prisma-client-js"
  output   = "../lib/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                   String   @id
  name                 String
  email                String   @unique
  username             String?  @unique
  displayUsername      String?
  phoneNumber          String?
  country              String?
  bio                  String?
  accountName          String?
  bankName             String?
  accountNumber        String?
  emailVerified        Boolean
  image                String?
  dob                  String?
  identificationType   String?
  identificationNumber String?
  onboardingCompleted  Boolean? @default(false)

  credits Int @default(20)

  earnings Int @default(0)

  subscription Subscription?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  sessions Session[]
  accounts Account[]
  socials  Socials[]
  jobs     Job[]
  Payment  Payment[]

  following Follow[] @relation("UserFollowing")
  followers Follow[] @relation("UserFollowers")

  jobPayments JobPayment[]
  applicants  Applicant[]

  @@unique([email, username])
  @@map("user")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime
  updatedAt DateTime
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime
  updatedAt             DateTime

  @@map("account")
}

model Verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?

  @@map("verification")
}

model Socials {
  id  String @id @default(uuid())
  url String

  User   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String

  @@map("socials")
}

model Job {
  id                 String  @id @default(uuid())
  type               String
  title              String
  slug               String? @unique
  description        String?
  category           String?
  jobLink            String?
  // deadline           String?
  reward             String?
  noOfWorkers        String?
  // estimatedTime      String?
  // estimatedTimeUnit  String?
  instructions       String?
  proofOfCompletion  String?
  submissionType     String?
  submissionRequired String?
  finalNotes         String?

  jobID String?

  status JobStatus @default(DRAFT)

  paymentVerified Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  User        User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  jobOpen     Boolean @default(true) // <-- NEW FIELD
  filledSlots Int     @default(0) // âœ… new field to track approved submissions

  jobPayments JobPayment[]
  applicants  Applicant[]

  @@unique([slug, userId])
  @@unique([jobID])
}

model SubscriptionPlan {
  id           String       @id @default(uuid())
  name         String       @default("Basic")
  billingCycle BillingCycle @default(MONTHLY)
  price        String
  durationDays String
  description  String
  features     Json?
  badge        String?
  isActive     Boolean      @default(true)

  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  Subscription Subscription[]
  Payment      Payment[]
}

model Subscription {
  id        String             @id @default(uuid())
  startDate DateTime
  endDate   DateTime
  status    SubscriptionStatus

  user               User             @relation(fields: [userId], references: [id])
  userId             String           @unique
  plan               SubscriptionPlan @relation(fields: [subscriptionPlanId], references: [id])
  subscriptionPlanId String
}

model Follow {
  id String @id @default(uuid())

  // The user who is following
  followerId String
  follower   User   @relation("UserFollowing", fields: [followerId], references: [id], onDelete: Cascade)

  // The user being followed
  followingId String
  following   User   @relation("UserFollowers", fields: [followingId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Ensure a user can't follow the same person twice
  @@unique([followerId, followingId])
  // Prevent self-follows at database level
  @@map("follow")
}

model JobPayment {
  id            String @id @default(uuid())
  txRef         String
  transactionId String
  amount        String

  status JobPaymentStatus @default(PENDING)

  User   User   @relation(fields: [userId], references: [id])
  userId String
  Job    Job    @relation(fields: [jobId], references: [id])
  jobId  String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Applicant {
  id String @id @default(uuid())

  User   User   @relation(fields: [userId], references: [id])
  userId String
  Job    Job    @relation(fields: [jobId], references: [id])
  jobId  String

  screenshots String[] @default([])
  shortText   String?
  paragraph   String?

  applicationID String

  rejectionReason String?

  status JobApplicationStatus @default(PENDING)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, jobId])
  @@unique([applicationID])
}

enum JobStatus {
  DRAFT
  PUBLISHED
  DELETED
  ARCHIVED
}

enum BillingCycle {
  MONTHLY
  ANNUALLY
}

enum SubscriptionStatus {
  ACTIVE
  EXPIRED
  CANCELED
}

model Payment {
  id String @id @default(uuid())

  amount        String
  transactionId String
  reference     String
  status        PaymentStatus @default(PENDING)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  user          User          @relation(fields: [userId], references: [id])
  userId        String

  plan               SubscriptionPlan @relation(fields: [subscriptionPlanId], references: [id])
  subscriptionPlanId String
}

enum PaymentStatus {
  PENDING
  SUCCESS
  FAILED
}

enum JobPaymentStatus {
  PENDING
  FAILED
  REFUNDED
  SUCCESS
}

enum JobApplicationStatus {
  PENDING
  APPROVED
  REJECTED
}
